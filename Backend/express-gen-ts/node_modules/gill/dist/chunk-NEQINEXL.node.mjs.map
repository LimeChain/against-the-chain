{"version":3,"sources":["../src/core/const.ts","../src/core/utils.ts","../src/programs/compute-budget.ts"],"names":[],"mappings":";;;;AACO,IAAM,gBAAmB,GAAA;AAKzB,IAAM,YAAe,GAAA;AAAA,EAC1B,OAAS,EAAA,8CAAA;AAAA,EACT,MAAQ,EAAA,8CAAA;AAAA,EACR,OAAS,EAAA;AACX;ACKO,SAAS,0BAA0B,IAAgD,EAAA;AACxF,EAAA,QAAQ,IAAM;AAAA,IACZ,KAAK,YAAa,CAAA,OAAA;AAChB,MAAO,OAAA,SAAA;AAAA,IACT,KAAK,YAAa,CAAA,MAAA;AAChB,MAAO,OAAA,QAAA;AAAA,IACT,KAAK,YAAa,CAAA,OAAA;AAChB,MAAO,OAAA,SAAA;AAAA,IACT;AACE,MAAO,OAAA,SAAA;AAAA;AAEb;AAEO,SAAS,eACd,KACmB,EAAA;AACnB,EAAA,OAAO,OAAO,KAAA,IAAS,QAAW,GAAA,KAAA,GAAQ,KAAM,CAAA,OAAA;AAClD;AAEO,SAAS,yBACd,KAC6B,EAAA;AAC7B,EAAI,IAAA,OAAO,UAAU,QAAY,IAAA,SAAA,IAAa,SAAS,KAAO,EAAA,KAAA,GAAQ,iBAAiB,KAAK,CAAA;AAC5F,EAAA,IAAI,CAAC,mBAAoB,CAAA,KAAK,GAAS,MAAA,IAAI,MAAM,iCAAiC,CAAA;AAClF,EAAA,yBAAA,CAA0B,KAAK,CAAA;AAC/B,EAAO,OAAA,KAAA;AACT;AAKO,SAAS,cAAc,QAAmC,EAAA;AAE/D,EAAA,OAAO,IAAI,IAAA,CAAK,YAAa,CAAA,OAAA,EAAS,EAAE,qBAAA,EAAuB,CAAE,EAAC,CAAE,CAAA,MAAA,CAAO,CAAG,EAAA,QAAQ,CAAK,GAAA,CAAA,CAAA;AAC7F;AC1CO,SAAS,6BACd,WACuG,EAAA;AACvG,EACE,OAAA,uBAAA,CAAwB,WAAa,EAAA,8BAA8B,CACnE,IAAA,qBAAA,CAAsB,WAAW,CAAA,IACjC,WAAY,CAAA,IAAA,CAAK,CAAC,CAAA,KAAM,wBAAyB,CAAA,mBAAA;AAErD;AAKO,SAAS,8BAA8B,EAAiC,EAAA;AAC7E,EAAA,OAAO,EAAG,CAAA,YAAA,CAAa,MAAO,CAAA,4BAA4B,EAAE,MAAU,IAAA,CAAA;AACxE;AAKO,SAAS,iCACd,WACuG,EAAA;AACvG,EACE,OAAA,uBAAA,CAAwB,WAAa,EAAA,8BAA8B,CACnE,IAAA,qBAAA,CAAsB,WAAW,CAAA,IACjC,WAAY,CAAA,IAAA,CAAK,CAAC,CAAA,KAAM,wBAAyB,CAAA,mBAAA;AAErD;AAKO,SAAS,kCAAkC,EAAiC,EAAA;AACjF,EAAA,OAAO,EAAG,CAAA,YAAA,CAAa,MAAO,CAAA,gCAAgC,EAAE,MAAU,IAAA,CAAA;AAC5E","file":"chunk-NEQINEXL.node.mjs","sourcesContent":["/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n","import {\n  assertIsTransactionSigner,\n  createNoopSigner,\n  isTransactionSigner,\n  type Address,\n  type TransactionSigner,\n} from \"@solana/kit\";\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): Address<TAddress> {\n  return typeof input == \"string\" ? input : input.address;\n}\n\nexport function checkedTransactionSigner<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): TransactionSigner<TAddress> {\n  if (typeof input === \"string\" || \"address\" in input == false) input = createNoopSigner(input);\n  if (!isTransactionSigner(input)) throw new Error(\"A signer or address is required\");\n  assertIsTransactionSigner(input);\n  return input;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n"]}