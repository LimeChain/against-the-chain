"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCompare = void 0;
exports.customDeepCompare = customDeepCompare;
const dist_1 = require("../../dist");
exports.deepCompare = customDeepCompare({});
function customDeepCompare(optionsOrCb, cb) {
    let optionsF, cbF = cb;
    if (typeof optionsOrCb === 'object') {
        optionsF = _processOptions(optionsOrCb);
    }
    else if (typeof optionsOrCb === 'function') {
        cbF = optionsOrCb;
        optionsF = { disregardDateException: false };
    }
    return (arg1, arg2) => {
        const opts = { ...optionsF };
        return _customDeepCompareHelper(arg1, arg2, opts, cbF, '');
    };
}
function _processOptions(opts) {
    const retVal = {
        disregardDateException: !!opts.disregardDateException,
    };
    if (!!opts.onlyCompareProps) {
        const ocp = opts.onlyCompareProps;
        if ((0, dist_1.isString)(ocp)) {
            retVal.onlyCompareProps = [ocp];
        }
        else if (Array.isArray(ocp)) {
            retVal.onlyCompareProps = [...ocp];
        }
    }
    if (!!opts.convertToDateProps) {
        const cdp = opts.convertToDateProps;
        if ((0, dist_1.isString)(cdp)) {
            retVal.convertToDateProps = { rec: true, props: [cdp] };
        }
        else if (Array.isArray(cdp)) {
            retVal.convertToDateProps = { rec: true, props: [...cdp] };
        }
        else if ((0, dist_1.isObject)(cdp)) {
            retVal.convertToDateProps = {
                rec: cdp.rec,
                props: Array.isArray(cdp.props) ? [...cdp.props] : [cdp.props],
            };
        }
    }
    return retVal;
}
function _customDeepCompareHelper(arg1, arg2, options, cb, paramKey) {
    if (!(0, dist_1.isObject)(arg1) || arg1 === null || !(0, dist_1.isObject)(arg2) || arg2 === null) {
        const isEqual = (arg1 === arg2);
        if (!isEqual && !!cb) {
            cb(paramKey, arg1, arg2);
        }
        return isEqual;
    }
    if (!options.disregardDateException && ((0, dist_1.isDate)(arg1) && (0, dist_1.isDate)(arg2))) {
        const isEqual = (arg1.getTime() === arg2.getTime());
        if (!isEqual && !!cb) {
            cb(paramKey, arg1, arg2);
        }
        return isEqual;
    }
    if (Array.isArray(arg1) || Array.isArray(arg2)) {
        if (!(Array.isArray(arg1) && Array.isArray(arg2))) {
            cb?.(paramKey, arg1, arg2);
            return false;
        }
        if (!cb && arg1.length !== arg2.length) {
            return false;
        }
        let length = arg1.length, isEqualF = true;
        if (arg2.length > arg1.length) {
            length = arg2.length;
        }
        for (let i = 0; i < length; i++) {
            const isEqual = _customDeepCompareHelper(arg1[i], arg2[i], options, cb, `Index: ${i}`);
            if (!isEqual) {
                if (!cb) {
                    return false;
                }
                isEqualF = false;
            }
        }
        return isEqualF;
    }
    let keys1 = Object.keys(arg1), keys2 = Object.keys(arg2);
    if (!!options?.onlyCompareProps) {
        const props = options.onlyCompareProps;
        keys1 = keys1.filter(key => props.includes(key));
        keys2 = keys2.filter(key => props.includes(key));
    }
    if (!cb && keys1.length !== keys2.length) {
        return false;
    }
    let convertToDateProps;
    if (!!options.convertToDateProps) {
        convertToDateProps = [...options.convertToDateProps.props];
        if (!options.convertToDateProps.rec) {
            delete options.convertToDateProps;
        }
    }
    let keys = keys1;
    if (keys2.length > keys1.length) {
        keys = keys2;
    }
    let isEqual = true;
    for (const key of keys) {
        const val1 = arg1[key], val2 = arg2[key];
        if (Object.prototype.hasOwnProperty.call(arg1, key) &&
            !Object.prototype.hasOwnProperty.call(arg2, key)) {
            if (!!cb) {
                cb(key, val1, 'not present');
                isEqual = false;
                continue;
            }
            else {
                return false;
            }
        }
        else if (!Object.prototype.hasOwnProperty.call(arg1, key) &&
            Object.prototype.hasOwnProperty.call(arg2, key)) {
            if (!!cb) {
                cb(key, 'not present', val2);
                isEqual = false;
                continue;
            }
            else {
                return false;
            }
        }
        if (!!convertToDateProps?.includes(key)) {
            const d1 = new Date(val1), d2 = new Date(val2);
            if (d1.getTime() !== d2.getTime()) {
                if (!!cb) {
                    cb(key, val1, val2);
                    isEqual = false;
                }
                else {
                    return false;
                }
            }
            continue;
        }
        const optionsF = { ...options };
        if (options.onlyCompareProps) {
            delete optionsF.onlyCompareProps;
        }
        if (!_customDeepCompareHelper(val1, val2, optionsF, cb, key)) {
            if (!cb) {
                return false;
            }
            isEqual = false;
            continue;
        }
    }
    return isEqual;
}
//# sourceMappingURL=deepCompare.js.map